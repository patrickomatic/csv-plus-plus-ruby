#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.6.2
# from Racc grammar file "".
#

require 'racc/parser.rb'


require_relative '../lexer/racc_lexer'

module CSVPlusPlus
  module Parser
    class Modifier < Racc::Parser

module_eval(<<'...end modifier.y/module_eval...', 'modifier.y', 60)
  extend ::T::Sig
  extend ::T::Generic
  include ::CSVPlusPlus::Lexer::RaccLexer

  ReturnType = type_member {{ fixed: ::T.nilable(::String) }}

  # @param cell_modifier [Modifier]
  # @param row_modifier [Modifier]
  def initialize(cell_modifier:, row_modifier:)
    super()

    @parsing_row = false
    @cell_modifier = ::CSVPlusPlus::Modifier::ModifierValidator.new(cell_modifier)
    @row_modifier = ::CSVPlusPlus::Modifier::ModifierValidator.new(row_modifier)
  end

  protected

  sig { override.params(input: ::String).returns(::T::Boolean) }
  def anything_to_parse?(input)
    @modifiers_to_parse = input.scan(/!?\[\[/).count

    if @modifiers_to_parse == 0
      assign_defaults!
      @return_value = input
    end

    @modifiers_to_parse > 0
  end

  sig { override.returns(::String) }
  def parse_subject
    'modifier'
  end

  sig { override.returns(ReturnType) }
  # The output of the parser
  def return_value
    @return_value
  end

  sig { override.returns(::CSVPlusPlus::Lexer::Tokenizer) }
  def tokenizer
    ::CSVPlusPlus::Lexer::Tokenizer.new(
      ignore: /\s+/,
      stop_fn: lambda do |scanner|
        return false unless scanner.scan(/\]\]/)

        @tokens << [:END_MODIFIERS, scanner.matched]
        @return_value = scanner.rest

        @modifiers_to_parse -= 1
        @modifiers_to_parse == 0
      end,
      tokens: [
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bborder\b/, token: 'border'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bbordercolor\b/, token: 'bordercolor'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bborderstyle\b/, token: 'borderstyle'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bcolor\b/, token: 'color'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bexpand\b/, token: 'expand'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bfontcolor\b/, token: 'fontcolor'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bfontfamily\b/, token: 'fontfamily'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bfontsize\b/, token: 'fontsize'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bformat\b/, token: 'format'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bfreeze\b/, token: 'freeze'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bhalign\b/, token: 'halign'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bnote\b/, token: 'note'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bnumberformat\b/, token: 'numberformat'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bvalidate\b/, token: 'validate'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bvalign\b/, token: 'valign'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\bvar\b/, token: 'var'),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /-?[1-9][\d.]*/, token: :NUMBER),
        ::CSVPlusPlus::Lexer::Token.new(
          regexp: /
            (?:
              \w+\s*:\s*'([^'\\]|\\.)*')    # allow for a single-quoted string which can accept any input and also allow 
                                            # for escaping via backslash (i.e., 'ain\\'t won\\'t something' is valid)
              |                             # - or -
            (?:'([^'\\]|\\.)*')             # allow for a single-quoted string which can accept any input and also allow 
              |
            (?:
              [\w,_:-]                      # something that accepts most basic input if it doesn't need to be quoted
              [\w\s,_:-]+                   # same thing but allow spaces in the middle
              [\w,_:-]                      # no spaces at the end
            )
          /x,
          token: :RIGHT_SIDE,
        ),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\[\[/, token: :START_CELL_MODIFIERS),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /!\[\[/, token: :START_ROW_MODIFIERS),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /\//, token: :MODIFIER_SEPARATOR),
        ::CSVPlusPlus::Lexer::Token.new(regexp: /=/, token: :EQ),
      ],
      alter_matches: {
        STRING: ->(s) { s.gsub(/^'|'$/, '') }
      },
    )
  end

  private

  def assign_defaults!
    @cell_modifier.modifier.take_defaults_from!(@row_modifier.modifier)
  end

  def parsing_row!
    @parsing_row = true
  end

  def finished_row!
    parsing_cell!
  end

  def parsing_cell!
    @parsing_row = false
    assign_defaults!
  end

  def modifier
    @parsing_row ? @row_modifier : @cell_modifier
  end
...end modifier.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
    23,    24,    25,    26,    27,    28,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    13,    14,    15,    16,    17,    18,    19,    20,
    21,    22,    23,    24,    25,    26,    27,    28,    30,    47,
     5,     4,     6,    31,    31,     5,    10,    32,    33,    34,
    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
    45,    46,    49,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63 ]

racc_action_check = [
     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     9,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,    31,    31,    31,    31,    31,    31,    31,    31,
    31,    31,    31,    31,    31,    31,    31,    31,    11,    29,
     0,     0,     1,    11,    29,     2,     6,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    23,    24,    25,    26,
    27,    28,    32,    33,    34,    35,    36,    37,    38,    39,
    40,    41,    42,    43,    44,    45,    46 ]

racc_action_pointer = [
    36,    52,    41,   nil,   nil,   nil,    56,   nil,   -17,    -1,
   nil,    41,   nil,    49,    50,    51,    52,    53,    54,    55,
    56,    57,   nil,    58,    59,    60,    61,    62,    63,    42,
   nil,    15,    59,    60,    61,    62,    66,    64,    65,    69,
    67,    68,    69,    70,    71,    72,    73,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil ]

racc_action_default = [
   -27,   -27,    -2,    -3,    -4,    -6,   -27,    -1,   -27,   -27,
    64,   -27,    -9,   -27,   -27,   -27,   -27,   -15,   -27,   -27,
   -27,   -27,   -20,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
    -5,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
   -27,   -27,   -27,   -27,   -27,   -27,   -27,    -7,    -8,   -10,
   -11,   -12,   -13,   -14,   -16,   -17,   -18,   -19,   -21,   -22,
   -23,   -24,   -25,   -26 ]

racc_goto_table = [
     3,     1,     7,    11,    29,     2,     8,     9,    48 ]

racc_goto_check = [
     3,     1,     3,     4,     4,     2,     5,     6,     7 ]

racc_goto_pointer = [
   nil,     1,     5,     0,    -5,     2,     2,   -23 ]

racc_goto_default = [
   nil,   nil,   nil,   nil,   nil,   nil,   nil,    12 ]

racc_reduce_table = [
  0, 0, :racc_error,
  2, 34, :_reduce_none,
  1, 34, :_reduce_none,
  1, 34, :_reduce_none,
  0, 38, :_reduce_4,
  4, 35, :_reduce_5,
  0, 39, :_reduce_6,
  4, 36, :_reduce_none,
  3, 37, :_reduce_none,
  1, 37, :_reduce_none,
  3, 40, :_reduce_10,
  3, 40, :_reduce_11,
  3, 40, :_reduce_12,
  3, 40, :_reduce_13,
  3, 40, :_reduce_14,
  1, 40, :_reduce_15,
  3, 40, :_reduce_16,
  3, 40, :_reduce_17,
  3, 40, :_reduce_18,
  3, 40, :_reduce_19,
  1, 40, :_reduce_20,
  3, 40, :_reduce_21,
  3, 40, :_reduce_22,
  3, 40, :_reduce_23,
  3, 40, :_reduce_24,
  3, 40, :_reduce_25,
  3, 40, :_reduce_26 ]

racc_reduce_n = 27

racc_shift_n = 64

racc_token_table = {
  false => 0,
  :error => 1,
  "![[" => 2,
  "[[" => 3,
  "]]" => 4,
  "=" => 5,
  "/" => 6,
  :END_MODIFIERS => 7,
  :EQ => 8,
  :HEX_COLOR => 9,
  :NUMBER => 10,
  :MODIFIER => 11,
  :MODIFIER_SEPARATOR => 12,
  :RIGHT_SIDE => 13,
  :START_CELL_MODIFIERS => 14,
  :START_ROW_MODIFIERS => 15,
  :STRING => 16,
  "border" => 17,
  "bordercolor" => 18,
  "borderstyle" => 19,
  "color" => 20,
  "expand" => 21,
  "fontcolor" => 22,
  "fontfamily" => 23,
  "fontsize" => 24,
  "format" => 25,
  "freeze" => 26,
  "halign" => 27,
  "note" => 28,
  "numberformat" => 29,
  "validate" => 30,
  "valign" => 31,
  "var" => 32 }

racc_nt_base = 33

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "\"![[\"",
  "\"[[\"",
  "\"]]\"",
  "\"=\"",
  "\"/\"",
  "END_MODIFIERS",
  "EQ",
  "HEX_COLOR",
  "NUMBER",
  "MODIFIER",
  "MODIFIER_SEPARATOR",
  "RIGHT_SIDE",
  "START_CELL_MODIFIERS",
  "START_ROW_MODIFIERS",
  "STRING",
  "\"border\"",
  "\"bordercolor\"",
  "\"borderstyle\"",
  "\"color\"",
  "\"expand\"",
  "\"fontcolor\"",
  "\"fontfamily\"",
  "\"fontsize\"",
  "\"format\"",
  "\"freeze\"",
  "\"halign\"",
  "\"note\"",
  "\"numberformat\"",
  "\"validate\"",
  "\"valign\"",
  "\"var\"",
  "$start",
  "modifiers_definition",
  "row_modifiers",
  "cell_modifiers",
  "modifiers",
  "@1",
  "@2",
  "modifier" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

# reduce 2 omitted

# reduce 3 omitted

module_eval(<<'.,.,', 'modifier.y', 25)
  def _reduce_4(val, _values, result)
     parsing_row!
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 27)
  def _reduce_5(val, _values, result)
     finished_row!
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 29)
  def _reduce_6(val, _values, result)
     parsing_cell!
    result
  end
.,.,

# reduce 7 omitted

# reduce 8 omitted

# reduce 9 omitted

module_eval(<<'.,.,', 'modifier.y', 35)
  def _reduce_10(val, _values, result)
     modifier.border = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 36)
  def _reduce_11(val, _values, result)
     modifier.bordercolor = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 37)
  def _reduce_12(val, _values, result)
     modifier.borderstyle = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 38)
  def _reduce_13(val, _values, result)
     modifier.color = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 39)
  def _reduce_14(val, _values, result)
     modifier.expand = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 40)
  def _reduce_15(val, _values, result)
     modifier.infinite_expand!
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 41)
  def _reduce_16(val, _values, result)
     modifier.fontcolor = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 42)
  def _reduce_17(val, _values, result)
     modifier.fontfamily = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 43)
  def _reduce_18(val, _values, result)
     modifier.fontsize = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 44)
  def _reduce_19(val, _values, result)
     modifier.format = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 45)
  def _reduce_20(val, _values, result)
     modifier.freeze!
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 46)
  def _reduce_21(val, _values, result)
     modifier.halign = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 47)
  def _reduce_22(val, _values, result)
     modifier.note = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 48)
  def _reduce_23(val, _values, result)
     modifier.numberformat = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 49)
  def _reduce_24(val, _values, result)
     modifier.validate = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 50)
  def _reduce_25(val, _values, result)
     modifier.valign = val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'modifier.y', 51)
  def _reduce_26(val, _values, result)
     modifier.var = val[2]
    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

    end   # class Modifier
  end   # module Parser
end   # module CSVPlusPlus
